\input{./econtexRoot.texinput}
\documentclass[\econtexRoot/SequentialEGM]{subfiles}
\onlyinsubfile{\externaldocument{\econtexRoot/SequentialEGM}}
\usepackage{\econtexSetup,\econark,\econtexShortcuts}

\begin{document}

\hypertarget{machine-learning}{}
\par\section{Multivariate Interpolation on Non-Rectilinear Grids}
\notinsubfile{\label{sec:gpr}}

This section presents alternative interpolation methods for non-rectilinear grids. First, I present the relatively simpler case of fast warped interpolation on a curvilinear grid, which improves upon the interpolation in \cite{White2015-fg}. Then, I present a machine learning approach to interpolation on unstructured grids based on Gaussian process regression as presented in \cite{Scheidegger2019-xf}.

\subsection{Warped Grid Interpolation (WGI)}

Assume we have a set of points indexed by $(i,j)$ in two dimensional space for which we have corresponding functional values in a third dimension, such that $f(x_{ij},y_{ij}) = z_{ij}$. In practice, we are interested in cases where the $z_{ij}$ are difficult to compute and $f(x_{ij},y_{ij})$ is unknown, so we are unable to compute them at other values of $x$ and $y$ --- which is why we want to interpolate\footnote{For this illustration, we generate $z$'s arbitrarily using the function $$f(x,y) = (xy)^{1/4}.$$}.

These $(x_{ij},y_{ij})$ points however are not evenly spaced and do not form a rectilinear grid which would make it easy to interpolate the function off the grid. Nevertheless, these points do have a regular structure as we will see.

\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{Figures/WarpedInterpolation.pdf}
    \caption{True function and curvilinear grid of points for which we know the value of the function.}
    \notinsubfile{\label{fig:warped_interp}}
\end{figure}

In Figure \ref{fig:warped_interp}, we can see the true function in 3D space, along with the points for which we actually know the value of the function.

The underlying regular structure comes from the points' position in the matrix, the $(i,j)$ coordinates. If we join the points along every row and every column, we can see that the resulting grid is regular and piecewise affine (curvilinear).

In Figure \ref{fig:homotopy} we see the values of the function at their index coordinate points in the matrix. We can see that there exists a mapping between the curvilinear grid and the index coordinates of the matrix.

\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{Figures/Homotopy.pdf}
    \caption{Homotopy between the curvilinear grid and the index coordinates of the matrix.}
    \notinsubfile{\label{fig:homotopy}}
\end{figure}

The objective is to be able to interpolate the value of the function at any point off the grid, where presumably we are only interested in points internal to the curvilinear space and not outside the boundaries. For example, we can imagine that we want an approximation to the function at the point $(x,y) = (3, 5)$ pictured Figure \ref{fig:mapping}. If we could find the corresponding point in the coordinate grid, interpolation would be straightforward.

We can find where the x-coordinate of the point of interest intersects with the index-coordinates of the matrix.

This is similar to assuming that we have 3 linear interpolators formed by connecting the points on the green lines in the x-direction, and for each interpolator we can approximate the corresponding y and z values using the grid data.

\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{Figures/Mapping.pdf}
    \caption{The method consist of extending the loci of points in the $x$ dimension to find the corresponding crossing points in the $y$ dimension.}
    \notinsubfile{\label{fig:mapping}}
\end{figure}

Now, for each circle in Figure \ref{fig:mapping}, we have a corresponding pair $(y,z)$, and we can interpolate in the y-direction to find the corresponding z-value for the point's y-coordinate\footnote{For more examples of the Warped Grid Interpolation method in action, see the github branch \href{https://github.com/alanlujan91/HARK/blob/map\_coordinates/examples/Interpolation/CurvilinearInterpolation.ipynb}{\texttt{alanlujan91/HARK@map\_coordinates}}.}.

\subsection{Gaussian Process Regression (GPR)}

Unstructured interpolation arises in many dynamic programming applications when using the endogenous grid method because the first order conditions might be highly non-linear and non-monotonic, or because boundary constraints induce kinks in the policy and value functions. In these cases, the grid points generated by the EGM step are not evenly spaced, leading to the need for curvilinear interpolation. We saw in the previous subsection an approach to curvilinear interpolation based on \cite{White2015-fg} that is incapable of interpolation on structured grids. A similar approach was presented in \cite{Ludwig2018-uz} which used Delaunay interpolation. However, this approach is not well suited for our purposes because triangulation can be computationally expensive and slow, often offsetting the efficiency gains from the Endogenous Grid Method.

As an alternative to these methods, I introduce the use of Gaussian process regression (GPR) along with the Endogenous Grid Method. GPR is computationally efficient, and tools exist to easily parallelize and take advantage of hardware such as GPU's.

\subsubsection{Gaussian Process Regression}

A Gaussian process is a random process for which every subset of random variables is jointly Gaussian or has a multivariate normal distribution.

\ifthenelse{\boolean{Web}}{}{
\end{document} \endinput
}
